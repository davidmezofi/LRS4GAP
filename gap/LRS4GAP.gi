#
# LRS4GAP: LRS interface for Linear Programming in GAP
#
# Implementations
#
# LP: A*x>=rhs, obj*x -> max
# Non checking!!!
InstallGlobalFunction( LRS_LPSolveNC, function(A,rhs,obj)
	local LRS_EXE,tmpdir,prob_file,solv_file,out,i,j,x,ret;
	# preparing problem and solution files
	LRS_EXE:=Filename(DirectoriesPackagePrograms("LRS4GAP"), "lrs");
	tmpdir:=DirectoryTemporary();
	prob_file:=Filename( tmpdir, "gaplp.ine");
	solv_file:=Filename( tmpdir, "gaplp.sol" );
	out:=OutputTextFile(prob_file,false);
	SetPrintFormattingStatus(out,false);
	# writing down the problem
	AppendTo(out, "Temporary\n", "* Created by GAP\n" );
	AppendTo(out, "H-representation\n", "begin\n" );
	AppendTo(out, Size(A), " ", Size(A[1])+1, " rational\n" );
	for i in [1..Size(A)] do
		AppendTo(out, -rhs[i]);
		for j in [1..Size(A[1])] do
			AppendTo(out, " ", A[i][j]);
		od;
		AppendTo(out, "\n");
	od;
	AppendTo(out, "end\n" );
	AppendTo(out, "lponly\n" );
	AppendTo(out, "maximize 0" );
	for x in obj do AppendTo(out, " ", x); od;
	AppendTo(out, "\n");
	CloseStream(out);
	# solving the problem
	Exec( Concatenation(
		LRS_EXE, " ", prob_file,
		" | egrep \"^No feasible|^\\*Unbounded|^\\*Primal\" > ",
		solv_file ) );
	# reading in the solution
	out:=InputTextFile( solv_file );
	ret:=ReadAll(out);
	CloseStream(out);
	# deleting the files
	Exec( Concatenation( "rm ", prob_file ) );
	Exec( Concatenation( "rm ", solv_file ) );
	# interpreting and returning the solution
	if ret{[1..3]}="No " then
		Info( InfoWarning, 1, "No feasible solution" );
		return [fail,"No feasible solution"];
	elif ret{[1..3]}="*Un" then
		Info( InfoWarning, 1, "Unbounded solution" );
		return [fail,"Unbounded solution"];
	else
		ret:=ret{[10..Size(ret)-2]};
		ret:=SplitString(ReplacedString(ret,"= ","=")," ");
		ret:=List(ret,x->EvalString(SplitString(x,"=")[2]));
		return [ret,obj*ret];
	fi;
end );

InstallGlobalFunction( LRS_Inputcheck, function( A, rhs, obj )
	local nrows,ncols;
	if IsList(rhs) and ForAll(rhs,IsRat) then
		nrows:=Size(rhs);
	else
		Info( InfoWarning, 1, "Wrong right hand side in LP input" );
		return false;
	fi;
	if IsList(obj) and ForAll(obj,IsRat) then
		ncols:=Size(obj);
	else
		Info( InfoWarning, 1, "Wrong objective in LP input" );
		return false;
	fi;
	if IsMatrix(A) and ForAll(Concatenation(A),IsRat) then
		if Size(A)=nrows and Size(A[1])=ncols then
			return true;
		else
			Info( InfoWarning, 1, "Wrong dimensions in LP input" );
			return false;
		fi;
	else
		Info( InfoWarning, 1, "Wrong matrix in LP input" );
		return false;
	fi;
end );

InstallGlobalFunction( LRS_LPSolveMax, function( A, rhs, obj )
	if LRS_Inputcheck(A,rhs,obj) then
		return LRS_LPSolveNC(A,rhs,obj);
	else
		Error("wrong input");
	fi;
end );

InstallGlobalFunction( LRS_LPSolveMin, function( A, rhs, obj )
	local ret;
	if LRS_Inputcheck(A,rhs,obj) then
		ret:=LRS_LPSolveNC(A,rhs,-obj);
		return [ret[1],-ret[2]];
	else
		Error("wrong input");
	fi;
end );

InstallGlobalFunction( LRS_Export2FreeMPS, function(A,rhs,obj,filename)
	local nrows,ncols,n_nonzeros,out,i,j;
	if not LRS_Inputcheck(A,rhs,obj) then
	       return Error("wrong input");
	fi;
	nrows:=Size(A);
	ncols:=Size(A[1]);
	n_nonzeros:=Number(Flat(A),x->x<>0);
	# HEADER
	out:=OutputTextFile(filename,false);
	SetPrintFormattingStatus(out,false);
	AppendTo(out, "* Problem: Generated by LRS4GAP\n" );
	AppendTo(out, "* Class: LP\n" );
	AppendTo(out, "* Rows: ", nrows, "\n" );
	AppendTo(out, "* Columns: ", ncols, "\n" );
	AppendTo(out, "* Non-zeros: ", n_nonzeros, "\n" );
	AppendTo(out, "* Format: Free MPS\n", "*\nNAME\n" );
	# ROWS
	AppendTo(out, "ROWS\n N  R0\n" );
	for i in [1..nrows] do
		AppendTo(out, " G  R", i, "\n");
	od;
	# COLUMNS
	AppendTo(out, "COLUMNS\n" );
	for i in [1..ncols] do
		AppendTo(out, " C", i, " R0 ", obj[i], "\n");
		for j in [1..nrows] do
			AppendTo(out, " C", i, " R", j, " ", A[j][i], "\n");
		od;
	od;
	# RIGHT HAND SIDE
	AppendTo(out, "RHS\n");
	for i in [1..nrows] do
		AppendTo(out, " RHS1 R", i, " ", rhs[i], "\n");
	od;
	# BOUNDS (making the variables free)
	AppendTo(out, "BOUNDS\n");
	for i in [1..ncols] do
		AppendTo(out, " FR BND1 C", i, "\n");
	od;
	# closing the file
	AppendTo(out, "ENDATA\n");
	CloseStream(out);
	return 0;
end );
